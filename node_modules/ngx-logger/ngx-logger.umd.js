(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/common/http'), require('@angular/core'), require('rxjs/Observable'), require('rxjs/add/observable/of')) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/common', '@angular/common/http', '@angular/core', 'rxjs/Observable', 'rxjs/add/observable/of'], factory) :
	(factory((global['ngx-logger'] = {}),global.common,global.http,global.core,global.Observable));
}(this, (function (exports,common,http,core,Observable) { 'use strict';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NGXLoggerHttpService = (function () {
    function NGXLoggerHttpService(http$$1) {
        this.http = http$$1;
    }
    /**
     * @param {?} url
     * @param {?} message
     * @param {?} additional
     * @param {?} metaData
     * @return {?}
     */
    NGXLoggerHttpService.prototype.logOnServer = /**
     * @param {?} url
     * @param {?} message
     * @param {?} additional
     * @param {?} metaData
     * @return {?}
     */
    function (url, message, additional, metaData) {
        var /** @type {?} */ body = {
            message: message,
            additional: additional,
            level: metaData.level,
            timestamp: metaData.timestamp,
            fileName: metaData.fileName,
            lineNumber: metaData.lineNumber
        };
        var /** @type {?} */ options = {
            headers: new http.HttpHeaders().set('Content-Type', 'application/json')
        };
        return this.http.post(url, body, options);
    };
    NGXLoggerHttpService.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    NGXLoggerHttpService.ctorParameters = function () { return [
        { type: http.HttpClient, },
    ]; };
    return NGXLoggerHttpService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {number} */
var NgxLoggerLevel = {
    TRACE: 0,
    DEBUG: 1,
    INFO: 2,
    LOG: 3,
    WARN: 4,
    ERROR: 5,
    OFF: 6,
};
NgxLoggerLevel[NgxLoggerLevel.TRACE] = "TRACE";
NgxLoggerLevel[NgxLoggerLevel.DEBUG] = "DEBUG";
NgxLoggerLevel[NgxLoggerLevel.INFO] = "INFO";
NgxLoggerLevel[NgxLoggerLevel.LOG] = "LOG";
NgxLoggerLevel[NgxLoggerLevel.WARN] = "WARN";
NgxLoggerLevel[NgxLoggerLevel.ERROR] = "ERROR";
NgxLoggerLevel[NgxLoggerLevel.OFF] = "OFF";

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var LoggerConfig = (function () {
    function LoggerConfig() {
    }
    return LoggerConfig;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NGXLoggerConfigEngine = (function () {
    function NGXLoggerConfigEngine(config) {
        this.config = config;
        this._config = config;
    }
    /**
     * @param {?} config
     * @return {?}
     */
    NGXLoggerConfigEngine.prototype.updateConfig = /**
     * @param {?} config
     * @return {?}
     */
    function (config) {
        this._config = config;
    };
    /**
     * @return {?}
     */
    NGXLoggerConfigEngine.prototype.getConfig = /**
     * @return {?}
     */
    function () {
        return this._config;
    };
    return NGXLoggerConfigEngine;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NGXLoggerUtils = (function () {
    function NGXLoggerUtils() {
    }
    /**
     * @param {?} timestamp
     * @param {?} logLevel
     * @param {?} fileName
     * @param {?} lineNumber
     * @return {?}
     */
    NGXLoggerUtils.prepareMetaString = /**
     * @param {?} timestamp
     * @param {?} logLevel
     * @param {?} fileName
     * @param {?} lineNumber
     * @return {?}
     */
    function (timestamp, logLevel, fileName, lineNumber) {
        return timestamp + " " + logLevel + " [" + fileName + ":" + lineNumber + "]";
    };
    /**
     * @param {?} level
     * @return {?}
     */
    NGXLoggerUtils.getColor = /**
     * @param {?} level
     * @return {?}
     */
    function (level) {
        switch (level) {
            case NgxLoggerLevel.TRACE:
                return 'blue';
            case NgxLoggerLevel.DEBUG:
                return 'teal';
            case NgxLoggerLevel.INFO:
            case NgxLoggerLevel.LOG:
                return 'gray';
            case NgxLoggerLevel.WARN:
            case NgxLoggerLevel.ERROR:
                return 'red';
            case NgxLoggerLevel.OFF:
            default:
                return;
        }
    };
    /**
     * This allows us to see who called the logger
     * @return {string}
     * @private
     */
    /**
     * This allows us to see who called the logger
     * @return {?}
     */
    NGXLoggerUtils.getCallerDetails = /**
     * This allows us to see who called the logger
     * @return {?}
     */
    function () {
        var /** @type {?} */ err = (new Error(''));
        // this should produce the line which NGX Logger was called
        var /** @type {?} */ callerLine = err.stack.split('\n')[4].split('/');
        // returns the file:lineNumber
        var /** @type {?} */ fileLineNumber = callerLine[callerLine.length - 1].replace(/[)]/g, '').split(':');
        return {
            fileName: fileLineNumber[0],
            lineNumber: fileLineNumber[1]
        };
    };
    /**
     * @param {?} message
     * @return {?}
     */
    NGXLoggerUtils.prepareMessage = /**
     * @param {?} message
     * @return {?}
     */
    function (message) {
        try {
            if (message instanceof Error) {
                message = message.stack;
            }
            else if (typeof message !== 'string') {
                message = JSON.stringify(message, null, 2);
            }
        }
        catch (/** @type {?} */ e) {
            // additional = [message, ...additional];
            message = 'The provided "message" value could not be parsed with JSON.stringify().';
        }
        return message;
    };
    /**
     * @param {?} additional
     * @return {?}
     */
    NGXLoggerUtils.prepareAdditionalParameters = /**
     * @param {?} additional
     * @return {?}
     */
    function (additional) {
        if (additional === null || additional === undefined) {
            return null;
        }
        return additional.map(function (next, idx) {
            try {
                // We just want to make sure the JSON can be parsed, we do not want to actually change the type
                return next;
            }
            catch (/** @type {?} */ e) {
                return "The additional[" + idx + "] value could not be parsed using JSON.stringify().";
            }
        });
    };
    return NGXLoggerUtils;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Levels = [
    'TRACE',
    'DEBUG',
    'INFO',
    'LOG',
    'WARN',
    'ERROR',
    'OFF'
];
var NGXLogger = (function () {
    function NGXLogger(httpService, loggerConfig, platformId) {
        this.httpService = httpService;
        this.platformId = platformId;
        this._isIE = common.isPlatformBrowser(platformId) &&
            !!(navigator.userAgent.indexOf('MSIE') !== -1 || navigator.userAgent.match(/Trident\//) || navigator.userAgent.match(/Edge\//));
        // each instance of the logger should have their own config engine
        this.configService = new NGXLoggerConfigEngine(loggerConfig);
    }
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    NGXLogger.prototype.trace = /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    function (message) {
        var additional = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            additional[_i - 1] = arguments[_i];
        }
        this._log(NgxLoggerLevel.TRACE, message, additional);
    };
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    NGXLogger.prototype.debug = /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    function (message) {
        var additional = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            additional[_i - 1] = arguments[_i];
        }
        this._log(NgxLoggerLevel.DEBUG, message, additional);
    };
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    NGXLogger.prototype.info = /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    function (message) {
        var additional = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            additional[_i - 1] = arguments[_i];
        }
        this._log(NgxLoggerLevel.INFO, message, additional);
    };
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    NGXLogger.prototype.log = /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    function (message) {
        var additional = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            additional[_i - 1] = arguments[_i];
        }
        this._log(NgxLoggerLevel.LOG, message, additional);
    };
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    NGXLogger.prototype.warn = /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    function (message) {
        var additional = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            additional[_i - 1] = arguments[_i];
        }
        this._log(NgxLoggerLevel.WARN, message, additional);
    };
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    NGXLogger.prototype.error = /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    function (message) {
        var additional = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            additional[_i - 1] = arguments[_i];
        }
        this._log(NgxLoggerLevel.ERROR, message, additional);
    };
    /**
     * @param {?} config
     * @return {?}
     */
    NGXLogger.prototype.updateConfig = /**
     * @param {?} config
     * @return {?}
     */
    function (config) {
        this.configService.updateConfig(config);
    };
    /**
     * @param {?} level
     * @param {?} metaString
     * @param {?} message
     * @param {?} additional
     * @return {?}
     */
    NGXLogger.prototype._logIE = /**
     * @param {?} level
     * @param {?} metaString
     * @param {?} message
     * @param {?} additional
     * @return {?}
     */
    function (level, metaString, message, additional) {
        // make sure additional isn't null or undefined so that ...additional doesn't error
        additional = additional || [];
        switch (level) {
            case NgxLoggerLevel.WARN:
                console.warn.apply(console, [metaString + " ", message].concat(additional));
                break;
            case NgxLoggerLevel.ERROR:
                console.error.apply(console, [metaString + " ", message].concat(additional));
                break;
            case NgxLoggerLevel.INFO:
                console.info.apply(console, [metaString + " ", message].concat(additional));
                break;
            default:
                console.log.apply(console, [metaString + " ", message].concat(additional));
        }
    };
    /**
     * @param {?} level
     * @param {?} message
     * @param {?=} additional
     * @param {?=} logOnServer
     * @return {?}
     */
    NGXLogger.prototype._log = /**
     * @param {?} level
     * @param {?} message
     * @param {?=} additional
     * @param {?=} logOnServer
     * @return {?}
     */
    function (level, message, additional, logOnServer) {
        var _this = this;
        if (additional === void 0) { additional = []; }
        if (logOnServer === void 0) { logOnServer = true; }
        if (!message) {
            return;
        }
        var /** @type {?} */ logLevelString = Levels[level];
        message = NGXLoggerUtils.prepareMessage(message);
        // only use validated parameters for HTTP requests
        var /** @type {?} */ validatedAdditionalParameters = NGXLoggerUtils.prepareAdditionalParameters(additional);
        var /** @type {?} */ timestamp = new Date().toISOString();
        var /** @type {?} */ config = this.configService.getConfig();
        var /** @type {?} */ callerDetails = NGXLoggerUtils.getCallerDetails();
        if (logOnServer && config.serverLoggingUrl && level >= config.serverLogLevel) {
            var /** @type {?} */ metaData = {
                level: level,
                timestamp: timestamp,
                fileName: callerDetails.fileName,
                lineNumber: callerDetails.lineNumber,
            };
            // Allow logging on server even if client log level is off
            this.httpService.logOnServer(config.serverLoggingUrl, message, validatedAdditionalParameters, metaData).subscribe(function (res) {
                // I don't think we should do anything on success
            }, function (error) {
                _this._log(NgxLoggerLevel.ERROR, "FAILED TO LOG ON SERVER: " + message, [error], false);
            });
        }
        // if no message or the log level is less than the environ
        if (level < config.level) {
            return;
        }
        var /** @type {?} */ metaString = NGXLoggerUtils.prepareMetaString(timestamp, logLevelString, callerDetails.fileName, callerDetails.lineNumber);
        // Coloring doesn't work in IE
        if (this._isIE) {
            return this._logIE(level, metaString, message, additional);
        }
        var /** @type {?} */ color = NGXLoggerUtils.getColor(level);
        console.log.apply(console, ["%c" + metaString, "color:" + color, message].concat((additional || [])));
    };
    NGXLogger.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    NGXLogger.ctorParameters = function () { return [
        { type: NGXLoggerHttpService, },
        { type: LoggerConfig, },
        { type: undefined, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] },] },
    ]; };
    return NGXLogger;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NGXLoggerMock = (function () {
    function NGXLoggerMock() {
    }
    /**
     * @param {?} message
     * @return {?}
     */
    NGXLoggerMock.prototype.trace = /**
     * @param {?} message
     * @return {?}
     */
    function (message) {
    };
    /**
     * @param {?} message
     * @return {?}
     */
    NGXLoggerMock.prototype.debug = /**
     * @param {?} message
     * @return {?}
     */
    function (message) {
    };
    /**
     * @param {?} message
     * @return {?}
     */
    NGXLoggerMock.prototype.info = /**
     * @param {?} message
     * @return {?}
     */
    function (message) {
    };
    /**
     * @param {?} message
     * @return {?}
     */
    NGXLoggerMock.prototype.log = /**
     * @param {?} message
     * @return {?}
     */
    function (message) {
    };
    /**
     * @param {?} message
     * @return {?}
     */
    NGXLoggerMock.prototype.warn = /**
     * @param {?} message
     * @return {?}
     */
    function (message) {
    };
    /**
     * @param {?} message
     * @return {?}
     */
    NGXLoggerMock.prototype.error = /**
     * @param {?} message
     * @return {?}
     */
    function (message) {
    };
    NGXLoggerMock.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    NGXLoggerMock.ctorParameters = function () { return []; };
    return NGXLoggerMock;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * CustomNGXLoggerService is designed to allow users to get a new instance of a logger
 */
var CustomNGXLoggerService = (function () {
    function CustomNGXLoggerService(httpService, platformId) {
        this.httpService = httpService;
        this.platformId = platformId;
    }
    /**
     * @param {?} config
     * @param {?=} httpService
     * @return {?}
     */
    CustomNGXLoggerService.prototype.create = /**
     * @param {?} config
     * @param {?=} httpService
     * @return {?}
     */
    function (config, httpService) {
        // you can inject your own httpService or use the default,
        return new NGXLogger(httpService || this.httpService, config, this.platformId);
    };
    CustomNGXLoggerService.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    CustomNGXLoggerService.ctorParameters = function () { return [
        { type: NGXLoggerHttpService, },
        { type: undefined, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] },] },
    ]; };
    return CustomNGXLoggerService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * CustomNGXLoggerServiceMock is a mock for CustomNGXLoggerService
 */
var CustomNGXLoggerServiceMock = (function () {
    function CustomNGXLoggerServiceMock() {
    }
    /**
     * @return {?}
     */
    CustomNGXLoggerServiceMock.prototype.create = /**
     * @return {?}
     */
    function () {
        // you can inject your own httpService or use the default,
        return new NGXLoggerMock();
    };
    return CustomNGXLoggerServiceMock;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NGXLoggerHttpServiceMock = (function () {
    function NGXLoggerHttpServiceMock() {
    }
    /**
     * @param {?} url
     * @param {?} message
     * @param {?} additional
     * @param {?} timestamp
     * @param {?} logLevel
     * @return {?}
     */
    NGXLoggerHttpServiceMock.prototype.logOnServer = /**
     * @param {?} url
     * @param {?} message
     * @param {?} additional
     * @param {?} timestamp
     * @param {?} logLevel
     * @return {?}
     */
    function (url, message, additional, timestamp, logLevel) {
        return Observable.Observable.of({});
    };
    return NGXLoggerHttpServiceMock;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var HttpMetaDataInterface = (function () {
    function HttpMetaDataInterface() {
    }
    return HttpMetaDataInterface;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var LoggerModule = (function () {
    function LoggerModule() {
    }
    /**
     * @param {?} config
     * @return {?}
     */
    LoggerModule.forRoot = /**
     * @param {?} config
     * @return {?}
     */
    function (config) {
        return {
            ngModule: LoggerModule,
            providers: [
                { provide: LoggerConfig, useValue: config || {} },
                NGXLogger,
                NGXLoggerHttpService,
                CustomNGXLoggerService
            ]
        };
    };
    /**
     * @return {?}
     */
    LoggerModule.forChild = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: LoggerModule,
            providers: [
                NGXLogger,
                NGXLoggerHttpService,
                CustomNGXLoggerService
            ]
        };
    };
    LoggerModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        http.HttpClientModule
                    ]
                },] },
    ];
    return LoggerModule;
}());

exports.LoggerModule = LoggerModule;
exports.NGXLoggerMock = NGXLoggerMock;
exports.Levels = Levels;
exports.NGXLogger = NGXLogger;
exports.LoggerConfig = LoggerConfig;
exports.CustomNGXLoggerService = CustomNGXLoggerService;
exports.CustomNGXLoggerServiceMock = CustomNGXLoggerServiceMock;
exports.NGXLoggerHttpService = NGXLoggerHttpService;
exports.NGXLoggerHttpServiceMock = NGXLoggerHttpServiceMock;
exports.NGXLoggerUtils = NGXLoggerUtils;
exports.NgxLoggerLevel = NgxLoggerLevel;
exports.HttpMetaDataInterface = HttpMetaDataInterface;

Object.defineProperty(exports, '__esModule', { value: true });

})));
